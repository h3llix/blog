---
title: Understanding SSH workflow
source: https://medium.com/@hellomudit/understanding-ssh-workflow-66a0e8d4bf65
author:
  - "[[Mudit Maheshwari]]"
published: 2017-09-24
created: 2025-02-01
description: Telnet is used to communicate with a remote server. But, Telnet is not a secure communication protocol because it does not use any security mechanism and transfers the data over network/internet in a…
tags:
  - clippings
aliases:
  - https://www.youtube.com/watch?time_continue=197&v=rlMfRa7vfO8&embeds_referring_euri=https%3A%2F%2Fwww.google.com%2F&source_ve_path=MzY4NDIsMzY4NDIsMzY4NDIsMzY4NDIsMTI3Mjk5LDEzOTExNywzNjg0MiwzNjg0MiwxMjcyOTksMTM5MTE3LDEzOTExNywyODY2Ng
cssclasses:
  - https://www.digitalocean.com/community/tutorials/understanding-the-ssh-encryption-and-connection-process
---
SSH service was created as a secure replacement for the unencrypted Telnet and uses cryptographic techniques to ensure that all communication to and from the remote server happens in an encrypted manner. It provides a mechanism for authenticating a remote user, transferring inputs from the client to the host, and relaying the output back to the client.

SSH protocol uses **symmetric encryption, asymmetric encryption and hashing** in order to secure transmission of information. The SSH connection between the client and the server happens in three stages:

Protocol verison and which crypotgrahic to use is also shareda and agreed\

![[Pasted image 20250202000724.png]]
1. Verification of the server by the client.
2. ==Generation of a session key to encrypt all the communication.==
3. Authentication of the client.

**1.VERIFICATION OF SERVER**
1. If the client is accessing the server for first time, client is asked to authenticate server manually by verifying public key of server. Public key of server can be found using **_ssh-keyscan_** command or can be found at different places(WHERE?GOOGLE!).Once the key is verified, the server is added in **_known_hosts_** file in ~/.ssh directory on client machine. The **_known_hosts_** file contains the information about all the verified servers by the client.
2. If the client is not accessing the server for the first time, the server’s identity is matched with previously recorded information in **_known_hosts_** file for verification.

**2.GENERATION OF SESSION KEY**

Generation of symmetrical session key

After the server is verified, both the parties negotiate a session key using a version of something called the [**Diffie-Hellman**](https://en.wikipedia.org/wiki/Diffie–Hellman_key_exchange) algorithm. This algorithm is designed in such a way that both the parties contribute equally in generation of session key. The generated session key is shared symmetric key i.e. the same key is used for encryption and decryption.

SSH uses asymmetric encryption in a few different places. During the initial key exchange process used to set up the symmetrical encryption (used to encrypt the session), asymmetrical encryption is used. In this stage, both parties produce temporary key pairs and exchange the public key in order to produce the shared secret that will be used for symmetrical encryption.

The more well-discussed use of asymmetrical encryption with SSH comes from SSH key-based authentication. SSH key pairs can be used to authenticate a client to a server. The client creates a key pair and then uploads the public key to any remote server it wishes to access. This is placed in a file called `authorized_keys` within the `~/.ssh` directory in the user account’s home directory on the remote server.

After the symmetrical encryption is established to secure communications between the server and client, the client must authenticate to be allowed access. The server can use the public key in this file to encrypt a challenge message to the client. If the client can prove that it was able to decrypt this message, it has demonstrated that it owns the associated private key. Then the server can set up the environment for the client.

**3.AUTHENTICATION OF THE CLIENT**
After symmetric encryption has been established, the authentication of the client happens as follows:

1. The client begins by sending an ID for the key pair it would like to authenticate with to the server.
2. The server checks the `authorized_keys` file of the account that the client is attempting to log into for the key ID.
3. If a public key with matching ID is found in the file, the server generates a random number and uses the public key to encrypt the number and sends this encrypted message.
4. If the client has the correct private key, it will decrypt the message to obtain the random number that was generated by the server.
5. The client combines the obtained random number with the shared session key and calculates the MD5 hash of this value.
6. The client then sends this MD5 hash back to the server as an answer to the encrypted number message.
7. The server uses the same shared session key and the original number that it sent to the client to calculate the MD5 value on its own. It compares its own calculation to the one that the client sent back. If these two values match, it proves that the client was in possession of the private key and the client is authenticated.


The basis of this procedure for classic Diffie-Hellman are:

- Both parties agree on a large prime number, which will serve as a seed value.
- Both parties agree on an encryption generator (typically AES), which will be used to manipulate the values in a predefined way.
- Independently, each party comes up with another prime number which is kept secret from the other party. This number is used as the private key for this interaction (different from the private SSH key used for authentication).
- The generated private key, the encryption generator, and the shared prime number are used to generate a public key that is derived from the private key, but which can be shared with the other party.
- Both participants then exchange their generated public keys.
- The receiving entity uses their own private key, the other party’s public key, and the original shared prime number to compute a shared secret key. Although this is independently computed by each party, using opposite private and public keys, it will result in the **same** shared secret key.
- The shared secret is then used to encrypt all communication that follows.
